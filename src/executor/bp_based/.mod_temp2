use std::{cell::UnsafeCell, collections::{hash_map::{self, Entry}, HashMap}, sync::{Arc, Mutex, RwLock, RwLockReadGuard}};

use crate::{error::ExecError, prelude::SchemaRef, tuple::Tuple, ColumnId, Field};

use super::{bytecode_expr::ByteCodeExpr, ResultIterator};

pub struct Pipeline {
    schema: SchemaRef, // Output schema
    scan: ScanType,
    out: Arc<dyn ResultBufferTrait>,
}

pub enum ScanType {
    TableScan, // Placeholder for table scan
    ResultScan(Arc<dyn ResultBufferTrait>), 
    SortMerge(Vec<(Arc<dyn ResultBufferTrait>, Vec<(ColumnId, bool, bool)>)>), 
    HashMerge((Arc<dyn ResultBufferTrait>, Arc<dyn ResultBufferTrait>, Vec<ByteCodeExpr>)), 
}

pub trait ResultBufferTrait {
    fn push(&self, tuple: Tuple) -> Result<(), ExecError>;
    fn to_iter(&self) -> Box<dyn ResultIterator>;
}

// Implement ResultBufferTrait for HashMap
pub struct InMemHashMap {
    exprs: Vec<ByteCodeExpr>,
    latch: Arc<RwLock<()>>,
    hash_map: UnsafeCell<HashMap<Vec<Field>, Vec<Tuple>>>,
}

impl InMemHashMap {
    pub fn new(exprs: Vec<ByteCodeExpr>) -> Self {
        InMemHashMap {
            exprs,
            latch: Arc::new(RwLock::new(())),
            hash_map: UnsafeCell::new(HashMap::new()),
        }
    }
}

pub struct InMemHashIterator<'a> {
    hash_map_guard: RwLockReadGuard<'a, ()>, // Guard to protect the hash_map
    iter_latch: Mutex<()>, // Guard to protect the iterator
    iter: UnsafeCell<hash_map::Iter<'a, Vec<Field>, Vec<Tuple>>>,
    current: UnsafeCell<Option<(&'a Vec<Tuple>, usize)>>, // Current tuple
}

impl<'a> ResultIterator for InMemHashIterator<'a> {
    fn next(&self) -> Option<Tuple> {
        let _iter_guard = self.iter_latch.lock().unwrap();
        let current = unsafe { &mut *self.current.get() };
        if let Some((tuples, mut idx)) = current {
            if idx < tuples.len() {
                let tuple = tuples[idx].copy();
                idx += 1;
                return Some(tuple);
            }
        }

        if let Some((_, tuples)) = unsafe { &mut *self.iter.get() }.next() {
            *current = Some((tuples, 0));
            self.next()
        } else {
            None
        }
    }
}

impl<'a> ResultBufferTrait for InMemHashMap {
    fn push(&self, tuple: Tuple) -> Result<(), ExecError> {
        let mut keys = Vec::with_capacity(self.exprs.len());
        for expr in &self.exprs {
            keys.push(expr.eval(&tuple)?);
        }

        let _guard = self.latch.write().unwrap();
        let hash_map = unsafe { &mut *self.hash_map.get() };
        match hash_map.entry(keys) {
            Entry::Occupied(mut entry) => {
                entry.get_mut().push(tuple);
            }
            Entry::Vacant(entry) => {
                entry.insert(vec![tuple]);
            }
        }
        Ok(())
    }

    fn to_iter(&self) -> Box<dyn ResultIterator<'a>> {
        let _guard = self.latch.read().unwrap();
        let hash_map = unsafe { &*self.hash_map.get() };
        let iter = hash_map.iter();
        Box::new(InMemHashIterator {
            hash_map_guard: self.latch.read().unwrap(),
            iter_latch: Mutex::new(()),
            iter: UnsafeCell::new(iter),
            current: UnsafeCell::new(None),
        })
    }
}

impl Pipeline {
    pub fn result_scan(schema: SchemaRef, scan: Arc<dyn ResultBufferTrait>, out: Arc<dyn ResultBufferTrait>) -> Self {
        Pipeline {
            schema,
            scan: ScanType::ResultScan(scan),
            out,
        }
    }

    pub fn sort_merge(schema: SchemaRef, scans: Vec<(Arc<dyn ResultBufferTrait>, Vec<(ColumnId, bool, bool)>)>, out: Arc<dyn ResultBufferTrait>) -> Self {
        Pipeline {
            schema,
            scan: ScanType::SortMerge(scans),
            out,
        }
    }

    pub fn hash_merge(schema: SchemaRef, left: Arc<dyn ResultBufferTrait>, right: Arc<dyn ResultBufferTrait>, exprs: Vec<ByteCodeExpr>, out: Arc<dyn ResultBufferTrait>) -> Self {
        Pipeline {
            schema,
            scan: ScanType::HashMerge((left, right, exprs)),
            out,
        }
    }
}

#[cfg(test)]
mod tests {
    // Check if Pipeline::result_scan() works correctly
    #[test]
    fn test_result_scan() {
        use super::{Pipeline, ResultBuffer};
        use crate::tuple::Tuple;
        use std::sync::Arc;

        let schema = Arc::new(vec![]);
        let scan = Arc::new(ResultBuffer { buffer: vec![Tuple::new()] });
        let out = Arc::new(ResultBuffer { buffer: vec![] });

        let pipeline = Pipeline::result_scan(schema, scan, out);

        match pipeline.scan {
            super::ScanType::ResultScan(_) => (),
            _ => panic!("Expected ResultScan"),
        }
    }
}