use std::{cmp::Reverse, collections::BinaryHeap,  sync::Arc};

use txn_storage::TxnStorageTrait;

use super::{bytecode_expr::ByteCodeExpr, volcano::PIpelineProjectIter, ResultBufferTrait};

use crate::{error::ExecError, log, log_info, log_trace, prelude::SchemaRef, tuple::{FromBool, Tuple}, ColumnId, Field};

pub struct Pipeline {
    scanner: Scanner,
    output: Arc<dyn ResultBufferTrait>,
}

pub enum IntraPipelineIter<T: TxnStorageTrait> {
    Scan(PipelineScan<T>),
    HashJoin(PipelineHashJoinIter<T>),
    Filter(PipelineFilterIter<T>),
    Project(PIpelineProjectIter<T>),
    Map(PipelineMapIter<T>),
}

type Key = Vec<u8>;

impl<T: TxnStorageTrait> IntraPipelineIter<T> {
    fn next(&mut self, txn: &T::TxnHandle) -> Result<Option<(Key, Tuple)>, ExecError> {
        // (key, tuple)
        match self {
            IntraPipelineIter::Scan(iter) => {
                log_trace!("ScanIter::next");
                iter.next(txn)
            }
            IntraPipelineIter::Filter(iter) => {
                log_trace!("PipelineFilterIter::next");
                iter.next(txn)
            }
            IntraPipelineIter::Project(iter) => {
                log_trace!("PIpelineProjectIter::next");
                iter.next(txn)
            }
            IntraPipelineIter::HashJoin(iter) => {
                log_trace!("HashJoin::next");
                iter.next(txn)
            }
            IntraPipelineIter::Map(iter) => {
                log_trace!("PipelineMapIter::next");
                iter.next(txn)
            }
        }
    }

    // Returns the output schema of the operator
    fn schema(&self) -> SchemaRef {
        match self {
            IntraPipelineIter::Scan(iter) => iter.schema(),
            IntraPipelineIter::Filter(iter) => iter.schema(),
            IntraPipelineIter::Project(iter) => iter.schema(),
            IntraPipelineIter::HashJoin(iter) => iter.schema(),
            IntraPipelineIter::Map(iter) => iter.schema(),
        }
    }

    fn print_inner(&self, indent: usize, out: &mut String) {
        match self {
            IntraPipelineIter::Scan(iter) => iter.print_inner(indent, out),
            IntraPipelineIter::Filter(iter) => iter.print_inner(indent, out),
            IntraPipelineIter::Project(iter) => iter.print_inner(indent, out),
            IntraPipelineIter::HashJoin(iter) => iter.print_inner(indent, out),
            IntraPipelineIter::Map(iter) => iter.print_inner(indent, out),
        }
    }
}

pub struct PipelineScanIter<T: TxnStorageTrait> {
    pub schema: SchemaRef,
    pub scanner: 
}

pub struct PipelineFilterIter<T: TxnStorageTrait> {
    pub schema: SchemaRef,
    pub input: Box<IntraPipelineIter<T>>,
    pub expr: ByteCodeExpr,
}

impl<T: TxnStorageTrait> PipelineFilterIter<T> {
    pub fn new(schema: SchemaRef, input: Box<IntraPipelineIter<T>>, expr: ByteCodeExpr) -> Self {
        Self {
            schema,
            input,
            expr,
        }
    }

    fn next(&mut self, txn: &T::TxnHandle) -> Result<Option<(Key, Tuple)>, ExecError> {
        loop {
            match self.input.next(txn)? {
                Some((k, tuple)) => {
                    if self.expr.eval(&tuple)? == Field::from_bool(true) {
                        log_info!("PipelineFilterIter::next: tuple: {:?}", tuple);
                        return Ok(Some((k, tuple)));
                    }
                }
                None => {
                    log_trace!("PipelineFilterIter::next: None");
                    return Ok(None);
                }
            }
        }
    }

    fn schema(&self) -> SchemaRef {
        self.schema.clone()
    }

    fn print_inner(&self, indent: usize, out: &mut String) {
        out.push_str(&format!("{}-> filter({:?})", " ".repeat(indent), self.expr));
        out.push_str("\n");
        self.input.print_inner(indent + 2, out);
    }
}

pub struct PipelineProjectIter<T: TxnStorageTrait> {
    pub schema: SchemaRef,
    pub input: Box<IntraPipelineIter<T>>,
    pub column_indices: Vec<ColumnId>,
}

impl<T: TxnStorageTrait> PipelineProjectIter<T> {
    pub fn new(
        schema: SchemaRef,
        input: Box<IntraPipelineIter<T>>,
        column_indices: Vec<ColumnId>,
    ) -> Self {
        Self {
            schema,
            input,
            column_indices,
        }
    }

    fn next(&mut self, txn: &T::TxnHandle) -> Result<Option<(Key, Tuple)>, ExecError> {
        match self.input.next(txn)? {
            Some((k, tuple)) => {
                let new_tuple = tuple.project(&self.column_indices);
                Ok(Some((k, new_tuple)))
            }
            None => {
                log_trace!("PIpelineProjectIter::next: None");
                Ok(None)
            }
        }
    }

    fn schema(&self) -> SchemaRef {
        self.schema.clone()
    }

    fn print_inner(&self, indent: usize, out: &mut String) {
        out.push_str(&format!("{}-> project(", " ".repeat(indent)));
        let mut split = "";
        out.push_str("[");
        for col_id in &self.column_indices {
            out.push_str(split);
            out.push_str(&format!("{:?}", col_id));
            split = ", ";
        }
        out.push_str("]");
        out.push_str(")\n");
        self.input.print_inner(indent + 2, out);
    }
}

pub struct PipelineMapIter<T: TxnStorageTrait> {
    pub schema: SchemaRef,
    pub input: Box<IntraPipelineIter<T>>,
    pub exprs: Vec<ByteCodeExpr>,
}

impl<T: TxnStorageTrait> PipelineMapIter<T> {
    pub fn new(
        schema: SchemaRef,
        input: Box<IntraPipelineIter<T>>,
        exprs: Vec<ByteCodeExpr>,
    ) -> Self {
        Self {
            schema,
            input,
            exprs,
        }
    }

    fn next(&mut self, txn: &T::TxnHandle) -> Result<Option<(Key, Tuple)>, ExecError> {
        match self.input.next(txn)? {
            Some((k, mut tuple)) => {
                for expr in &self.exprs {
                    tuple.push(expr.eval(&tuple)?);
                }
                Ok(Some((k, tuple)))
            }
            None => {
                log_trace!("PipelineMapIter::next: None");
                Ok(None)
            }
        }
    }

    fn schema(&self) -> SchemaRef {
        self.schema.clone()
    }

    fn print_inner(&self, indent: usize, out: &mut String) {
        out.push_str(&format!("{}-> map(", " ".repeat(indent)));
        let mut split = "";
        out.push_str("[");
        for expr in &self.exprs {
            out.push_str(split);
            out.push_str(&format!("{:?}", expr));
            split = ", ";
        }
        out.push_str("]");
        out.push_str(")\n");
        self.input.print_inner(indent + 2, out);
    }
}


pub enum Scanner {
    TableScan(Arc<dyn ResultBufferTrait>),
    MergeScan(Vec<(Arc<dyn ResultBufferTrait>, Vec<(ColumnId, bool, bool)>)>), // (scanner, Vec((col_id, asc, nulls_first)))
}

impl Pipeline {
    pub fn new(scanner: Scanner, output: Arc<dyn ResultBufferTrait>) -> Self {
        Self { scanner, output }
    }

    pub fn execute(&mut self) -> Result<Arc<dyn ResultBufferTrait>, ExecError> {
        match &self.scanner {
            Scanner::TableScan(scanner) => {
                let iter = scanner.iter_all();
                while let Some(tuple) = iter.next() {
                    self.output.insert(tuple);
                }
            }
            Scanner::MergeScan(scanners) => {
                let mut heap = BinaryHeap::new();
                let iters = scanners
                    .iter()
                    .enumerate()
                    .map(|(i, (scanner, sort_cols))| {
                        let iter = scanner.iter_all();
                        if let Some(tuple) = iter.next() {
                            heap.push(Reverse((
                                tuple.to_normalized_key_bytes(sort_cols),
                                (i, tuple),
                            )));
                        }
                        (iter, sort_cols)
                    })
                    .collect::<Vec<_>>();
                while let Some(Reverse((_, (i, tuple)))) = heap.pop() {
                    self.output.insert(tuple);
                    let (iter, sort_cols) = &iters[i];
                    if let Some(tuple) = iter.next() {
                        heap.push(Reverse((
                            tuple.to_normalized_key_bytes(sort_cols),
                            (i, tuple),
                        )));
                    }
                }
            }
        }
        Ok(self.output.clone())
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        executor::{bytecode_expr::colidx_expr, HashTable, ResultIterator, TupleResults},
        tuple::Tuple,
        Field,
    };

    use super::*;
    use std::{
        cell::UnsafeCell,
        collections::HashMap,
        sync::{
            atomic::{AtomicUsize, Ordering},
            Arc, RwLock, RwLockReadGuard,
        },
    };

    fn check_result(
        result: Arc<dyn ResultBufferTrait>,
        expected: &mut [Tuple],
        sorted: bool,
        verbose: bool,
    ) {
        let mut vec = Vec::new();
        let result = result.iter_all();
        while let Some(t) = result.next() {
            vec.push(t);
        }
        let mut result = vec;
        if sorted {
            result.sort();
            expected.sort();
        }
        let result_string = result
            .iter()
            .map(|t| t.to_pretty_string())
            .collect::<Vec<_>>()
            .join("\n");
        let expected_string = expected
            .iter()
            .map(|t: &Tuple| t.to_pretty_string())
            .collect::<Vec<_>>()
            .join("\n");
        if verbose {
            println!("--- Result ---\n{}", result_string);
            println!("--- Expected ---\n{}", expected_string);
        }
        assert_eq!(
            result, expected,
            "\n--- Result ---\n{}\n--- Expected ---\n{}\n",
            result_string, expected_string
        );
    }

    #[test]
    fn test_scan_pipeline() {
        let input = Arc::new(TupleResults::new());
        let mut expected = Vec::new();
        expected.push(Tuple::from_fields(vec![1.into(), "hello".into()]));
        expected.push(Tuple::from_fields(vec![2.into(), "world".into()]));

        for tuple in &expected {
            input.insert(tuple.copy());
        }
        let scanner = Scanner::TableScan(input.clone());
        let output = Arc::new(TupleResults::new());
        let mut pipeline = Pipeline::new(scanner, output);
        let output = pipeline.execute().unwrap();

        check_result(output, &mut expected, false, false);
    }

    #[test]
    fn test_sort_merge_pipeline_2_inputs() {
        let input1 = Arc::new(TupleResults::new());
        let mut expected1 = Vec::new();
        expected1.push(Tuple::from_fields(vec![1.into(), "hello".into()]));
        expected1.push(Tuple::from_fields(vec![3.into(), "world".into()]));
        expected1.push(Tuple::from_fields(vec![5.into(), "foo".into()]));

        for tuple in &expected1 {
            input1.insert(tuple.copy());
        }

        let input2 = Arc::new(TupleResults::new());
        let mut expected2 = Vec::new();
        expected2.push(Tuple::from_fields(vec![2.into(), "world".into()]));
        expected2.push(Tuple::from_fields(vec![4.into(), "hello".into()]));
        expected2.push(Tuple::from_fields(vec![6.into(), "bar".into()]));

        for tuple in &expected2 {
            input2.insert(tuple.copy());
        }

        let scanner = Scanner::MergeScan(vec![
            (input1.clone(), vec![(0, true, false)]),
            (input2.clone(), vec![(0, true, false)]),
        ]);
        let output = Arc::new(TupleResults::new());
        let mut pipeline = Pipeline::new(scanner, output);
        let output = pipeline.execute().unwrap();

        let mut expected = expected1;
        expected.extend(expected2);
        expected.sort();
        check_result(output, &mut expected, false, false);
    }

    #[test]
    fn test_sort_merge_pipeline_3_inputs() {
        let input1 = Arc::new(TupleResults::new());
        let mut expected1 = Vec::new();
        expected1.push(Tuple::from_fields(vec![1.into(), "hello".into()]));
        expected1.push(Tuple::from_fields(vec![3.into(), "bar".into()]));
        expected1.push(Tuple::from_fields(vec![3.into(), "world".into()]));

        for tuple in &expected1 {
            input1.insert(tuple.copy());
        }

        let input2 = Arc::new(TupleResults::new());
        let mut expected2 = Vec::new();
        expected2.push(Tuple::from_fields(vec![2.into(), "world".into()]));
        expected2.push(Tuple::from_fields(vec![3.into(), "bar".into()]));
        expected2.push(Tuple::from_fields(vec![3.into(), "foo".into()]));

        for tuple in &expected2 {
            input2.insert(tuple.copy());
        }

        let input3 = Arc::new(TupleResults::new());
        let mut expected3 = Vec::new();
        expected3.push(Tuple::from_fields(vec![7.into(), "baz".into()]));
        expected3.push(Tuple::from_fields(vec![8.into(), "qux".into()]));
        expected3.push(Tuple::from_fields(vec![9.into(), "quux".into()]));

        for tuple in &expected3 {
            input3.insert(tuple.copy());
        }

        let scanner = Scanner::MergeScan(vec![
            (input1.clone(), vec![(0, true, false), (1, true, false)]),
            (input2.clone(), vec![(0, true, false), (1, true, false)]),
            (input3.clone(), vec![(0, true, false), (1, true, false)]),
        ]);
        let output = Arc::new(TupleResults::new());
        let mut pipeline = Pipeline::new(scanner, output);
        let output = pipeline.execute().unwrap();

        let mut expected = expected1;
        expected.extend(expected2);
        expected.extend(expected3);
        expected.sort();
        check_result(output, &mut expected, false, false);
    }

    #[test]
    fn test_hash_join_pipeline() {
        let build_input = Arc::new(HashTable::new(vec![colidx_expr(0)]));
        let mut build_tuples = Vec::new();
        build_tuples.push(Tuple::from_fields(vec![1.into(), "hello".into()]));
        build_tuples.push(Tuple::from_fields(vec![2.into(), "world".into()]));
        build_tuples.push(Tuple::from_fields(vec![2.into(), "world".into()])); // Duplicate
        build_tuples.push(Tuple::from_fields(vec![3.into(), "foo".into()]));
        build_tuples.push(Tuple::from_fields(vec![3.into(), "bar".into()]));
        for tuple in &build_tuples {
            build_input.insert(tuple.copy());
        }

        let probe_input = Arc::new(TupleResults::new());
        let mut probe_tuples = Vec::new();
        probe_tuples.push(Tuple::from_fields(vec![1.into(), "hello".into()]));
        probe_tuples.push(Tuple::from_fields(vec![2.into(), "world".into()]));
        probe_tuples.push(Tuple::from_fields(vec![3.into(), "foo".into()]));
        probe_tuples.push(Tuple::from_fields(vec![3.into(), "bar".into()]));
        probe_tuples.push(Tuple::from_fields(vec![4.into(), "bar".into()]));
        for tuple in &probe_tuples {
            probe_input.insert(tuple.copy());
        }

        let scanner = Scanner::HashJoinScan(
            build_input.clone(),
            probe_input.clone(),
            vec![colidx_expr(0)],
        );
        let output = Arc::new(TupleResults::new());
        let mut pipeline = Pipeline::new(scanner, output);
        let output = pipeline.execute().unwrap();

        let mut expected = Vec::new();
        expected.push(Tuple::from_fields(vec![
            1.into(),
            "hello".into(),
            1.into(),
            "hello".into(),
        ]));
        expected.push(Tuple::from_fields(vec![
            2.into(),
            "world".into(),
            2.into(),
            "world".into(),
        ]));
        expected.push(Tuple::from_fields(vec![
            2.into(),
            "world".into(),
            2.into(),
            "world".into(),
        ]));
        expected.push(Tuple::from_fields(vec![
            3.into(),
            "foo".into(),
            3.into(),
            "foo".into(),
        ]));
        expected.push(Tuple::from_fields(vec![
            3.into(),
            "foo".into(),
            3.into(),
            "bar".into(),
        ]));
        expected.push(Tuple::from_fields(vec![
            3.into(),
            "bar".into(),
            3.into(),
            "foo".into(),
        ]));
        expected.push(Tuple::from_fields(vec![
            3.into(),
            "bar".into(),
            3.into(),
            "bar".into(),
        ]));

        check_result(output, &mut expected, true, false);
    }
}
